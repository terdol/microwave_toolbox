"""
This type stub file was generated by pyright.
"""

"""
General methods
"""
inkscape_exe = ...
convert_exe = ...
def convert_image(filename, format): # -> None:
    ...

Np2dB = ...
globsep = ...
globsep2 = ...
def ekpolyfit(x):
    ...

class dotdict(dict):
    """dot.notation access to dictionary attributes
    This class is not pickleable!!!
    objdict is pickleable, because it raises correct exceptions,
    dill instead of pickle does not work too.
    """
    __getattr__ = ...
    __setattr__ = ...
    __delattr__ = ...


class objectview:
    def __init__(self, d) -> None:
        ...
    


class objdict(dict):
    def __getattr__(self, name):
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    
    def __delattr__(self, name): # -> None:
        ...
    


def polarsample(x): # -> list[int]:
    """Samples the Smith Chart uniformly and returns the reflection coefficient values
    Args:
        x(float): Approximate distance between the points.
    Returns:
        list: list of reflection coefficient values in complex form
    """
    ...

class Flexlist(list):
    """This is a list implementation that supports indexing by list to return some elements of the list"""
    def __getitem__(self, keys): # -> list[Unknown]:
        ...
    


def tukey_window(alpha, N): # -> list[Unknown]:
    """
    Tukey window (also known as "tapered cosine window")
    Also available in scipy.signal
    """
    ...

def blackman_window(N): # -> NDArray[Unknown]:
    """
    Blackman-Harris window
    Also available in scipy.signal
    """
    ...

def gaussian_window(sigma, N): # -> list[Unknown]:
    """
    Gaussian window
    sigma should be smaller than or equal to 0.5
    Also available in scipy.signal
    Ref: Wikipedia
    """
    ...

def cmp(x, y): # -> int:
    """
    Replacement for built-in function cmp that was removed in Python 3

    Compare the two objects x and y and return an integer according to
    the outcome. The return value is negative if x < y, zero if x == y
    and strictly positive if x > y.
    """
    ...

def do_cprofile(func): # -> (*args: Unknown, **kwargs: Unknown) -> Unknown:
    ...

def printall(isimler, args): # -> None:
    ...

def prettystring(miktarlar, birim=...): # -> LiteralString:
    ...

def coef(birim):
    """ SI'dan Birim'e cevirmek icin katsayi """
    ...

def split_camel_case(str): # -> list[Unknown]:
    "Split string written with CamelCase to words. The first letter can be either lower or upper case."
    ...

def stripunit(sayi): # -> float:
    ...

def convert2pq(sayilar, defaultunits=...): # -> list[float] | Any:
    """
    Method to convert a string or string list to float after unit conversion to SI
    Units are extracted from strings.
    If there is not a unit in string, unit is taken from defaultunits
    """
    ...

def flatten(x): # -> list[Unknown]:
    """Flatten (an irregular) list of lists"""
    ...

def flatten2(l): # -> Generator[Unknown | basestring, None, None]:
    """Flatten (an irregular) list of lists (yield version of flatten)"""
    ...

def heatmap(data, row_labels, col_labels, ax=..., cbar_kw=..., cbarlabel=..., **kwargs): # -> tuple[Unknown, Unknown]:
    """
    Create a heatmap from a numpy array and two lists of labels.
    https://matplotlib.org/3.5.0/gallery/images_contours_and_fields/image_annotated_heatmap.html

    Parameters
    ----------
    data
        A 2D numpy array of shape (M, N).
    row_labels
        A list or array of length M with the labels for the rows.
    col_labels
        A list or array of length N with the labels for the columns.
    ax
        A `matplotlib.axes.Axes` instance to which the heatmap is plotted.  If
        not provided, use current axes or create a new one.  Optional.
    cbar_kw
        A dictionary with arguments to `matplotlib.Figure.colorbar`.  Optional.
    cbarlabel
        The label for the colorbar.  Optional.
    **kwargs
        All other arguments are forwarded to `imshow`.

    Usage:
    fig, ax = plt.subplots()

    im, cbar = heatmap(harvest, vegetables, farmers, ax=ax,
                   cmap="YlGn", cbarlabel="harvest [t/year]")
    texts = annotate_heatmap(im, valfmt="{x:.1f} t")
    """
    ...

def annotate_heatmap(im, data=..., valfmt=..., textcolors=..., threshold=..., **textkw): # -> list[Unknown]:
    """
    A function to annotate a heatmap.
    https://matplotlib.org/3.5.0/gallery/images_contours_and_fields/image_annotated_heatmap.html

    Parameters
    ----------
    im
        The AxesImage to be labeled.
    data
        Data used to annotate.  If None, the image's data is used.  Optional.
    valfmt
        The format of the annotations inside the heatmap.  This should either
        use the string format method, e.g. "$ {x:.2f}", or be a
        `matplotlib.ticker.Formatter`.  Optional.
    textcolors
        A pair of colors.  The first is used for values below a threshold,
        the second for those above.  Optional.
    threshold
        Value in data units according to which the colors from textcolors are
        applied.  If None (the default) uses the middle of the colormap as
        separation.  Optional.
    **kwargs
        All other arguments are forwarded to each call to `text` used to create
        the text labels.

    Usage:
    fig, ax = plt.subplots()

    im, cbar = heatmap(harvest, vegetables, farmers, ax=ax,
                   cmap="YlGn", cbarlabel="harvest [t/year]")
    texts = annotate_heatmap(im, valfmt="{x:.1f} t")
    """
    ...

def smooth(x, window_len=..., window=...): # -> ndarray[Any, dtype[bool_]]:
    """smooth the data using a window with requested size.

    This method is based on the convolution of a scaled window with the signal.
    The signal is prepared by introducing reflected copies of the signal
    (with the window size) in both ends so that transient parts are minimized
    in the begining and end part of the output signal.
    input:
        x: the input signal
        window_len: the dimension of the smoothing window; should be an odd integer
        window: either
                    window array with type list or numpy array with size window_len
                or
                    the type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
            flat window will produce a moving average smoothing.
    output:
        the smoothed signal
    example:
    t=linspace(-2,2,0.1)
    x=sin(t)+randn(len(t))*0.1
    y=smooth(x)
    see also:
    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
    scipy.signal.lfilter

    """
    ...

def peakdet(v, delta, x=...): # -> tuple[NDArray[Unknown], NDArray[Unknown]]:
    """
    Converted from MATLAB script at http://billauer.co.il/peakdet.html

    Returns two arrays

    function [maxtab, mintab]=peakdet(v, delta, x)
    %PEAKDET Detect peaks in a vector
    %        [MAXTAB, MINTAB] = PEAKDET(V, DELTA) finds the local
    %        maxima and minima ("peaks") in the vector V.
    %        MAXTAB and MINTAB consists of two columns. Column 1
    %        contains indices in V, and column 2 the found values.
    %
    %        With [MAXTAB, MINTAB] = PEAKDET(V, DELTA, X) the indices
    %        in MAXTAB and MINTAB are replaced with the corresponding
    %        X-values.
    %
    %        A point is considered a maximum peak if it has the maximal
    %        value, and was preceded (to the left) by a value lower by
    %        DELTA.

    % Eli Billauer, 3.4.05 (Explicitly not copyrighted).
    % This function is released to the public domain; Any use is allowed.

    """
    ...

def levenshtein_ratio_and_distance(s, t, ratio_calc=...): # -> Any | LiteralString:
    """ levenshtein_ratio_and_distance:
        Calculates levenshtein distance between two strings.
        If ratio_calc = True, the function computes the
        levenshtein distance ratio of similarity between two strings
        For all i and j, distance[i,j] will contain the Levenshtein
        distance between the first i characters of s and the
        first j characters of t
    """
    ...

if __name__ == "__main__":
    ...
